---
layout: post
title: Анализируем социальные сети(начало)
permalink: /2011/11/analyzen-part1/
---

Если спросить человека на улице о том, как его зовут и где он учился, это вызовет возможно недоумение,а возможно и начальную стадию агрессии к вам. В то же время в интернете люди публикуют о себе информацию совершенно свободно. Получить доступ к личным данным человека теперь очень просто, а узнать чего хотят люди? В начале 90тых появился термин "Коллаборативная фильтрация".
<blockquote>Коллаборативная фильтрация, cовместная фильтрация (англ. collaborative filtering) — метод, дающий автоматические прогнозы (фильтрацию) относительно интересов пользователя по собранной информации о вкусах множества пользователей (сотрудничающих между собой).</blockquote>

##Мы хотим узнать чего хочет человек? 
Проведем один маленький эксперимент,чтобы показать весь процесс анализа, который надо провести для решения подобной задачи. Я покажу лишь, как может выглядеть процесс. Задача и ее решение должны привести к быстрому profit'у дабы подогреть интерес к теме.

##Kanobu и Gamers

Есть такой user generated игровой портал - Kanobu.ru.
На нем больше 100к зарегистрированных пользователей, которые ведут блоги и общаются на игровую тематику. Все профили пользователей в открытом доступе. [http://kanobu.ru/accounts/]("http://kanobu.ru/accounts/"). Каждый пользователь может отметить для себя список любимых книг, фильмов и конечно игр. 
Мы можем получить эту информацию и провести анализ. 
Для разработки будем использовать Python. (*Причина - I hate Ruby.*) 
Полный исходный код хранится на [ссылка на github]("https://github.com/Partysun/analyzesn").

**Задачи:**

  - Получить имена игроков и их профили с сайта Kanobu.ru
  - Узнать любимые игры по профилю
  - Взять пользователя Kanobu и получить список людей со схожими вкусами.

*Profit!*

**Для получения информации**:

Используем библиотеку BeatifulSoup для парсинга html. urllib2 для работы с http запросами.
Инфу по установке и получению BS и urllib2 можно с легкостью найти в сети.
Для получения данных напишем модуль parseGames.py.

**Получаем список пользователей и их любимые игры**

'''python
.{% highlight html %}
def parseUsers(address='http://kanobu.ru/accounts/?ord=d&by=rating&page=', begin = 1, end = 3):
    """
        Возвращает список всех пользователей с адресами их страничек
    """
    for i in xrange(begin, end):
        try:            
            doc = BeautifulSoup(urlopen(address + str(i)), fromEncoding="utf-8")
            #находим всех пользователей на заданной странице.
            page = doc.find('ul', attrs = {'class':'min'})                   
            list = []
            for item in page.findAll({'li' : True,}):
                path = item.find({'a' : True})["href"]
                name = "%s" % item.find("h5").contents[0]
                list.append([name, path])

            return list              
        except URLError:
            # иногда сразу страницу не получается загрузить-попытаться снова
            i -= 1  

def parseGameByUser(address):
    """
        Возвращает словарь всех игр для пользователя
    """
    # Создаем полный путь до игр пользователя
    path = "http://kanobu.ru" + address     
     
    # Производим первоначальный анализ пользователя
    doc = BeautifulSoup(urlopen(path), fromEncoding="utf-8")
        
    # Находим количесвто игр у пользователя           
    tag = doc.findAll('a', {'href': address + 'favgames/'})            
    countOfGames = tag[1].string[7:]

    print "Обнаруженно %d игр." % int(countOfGames)

    if int(countOfGames) > 100: print "Геймер детектед!"
 
    # Находим кол-во страниц для парсинг с играми        
    countOfPages = int(countOfGames)/30.0

    countOfPages = math.ceil(countOfPages)        
    
    print "Обнаруженно %s страниц с играми." % int(countOfPages)

    path = path + "favgames/?page="
    # Создаем словарь с играми пользотеля
    games = []
    for i in xrange(1, int(countOfPages)+1):
        doc = BeautifulSoup(urlopen(path + str(i)), fromEncoding="utf-8")
        pages = doc.findAll('ul', {'class': 'tiny'})            
        for page in pages:
            for item in page.findAll("h5"):
                print item.string
                games.append(item.string)
           
    return games
{% endhighlight %}
'''

**Делаем методы для анализа данных**

Создадим отдельный модуль analysis.py
В нем будем собирать методы для анализа данных. Сейчас мы сделаем самое простое, что можно сделать. Выясним на сколько близки люди по совпадениям в их предпочтениях. Это нельзя назвать хорошим методом оценки подобия людей по их предпочтениям, но задача создать метод, который будет в дальнейшем вроде как заглушки. Можно будет переписать метод используя более точные алгоритмы. 

'''python

def sim(prefs, person1, person2):
    """Выясняет, на сколько близки два человека
в своих предпочтениях.

    Args: 
        prefs: Список людей и их предпочтений.
        person1, person2: Два человека из списка.

    Returns:
        Количество схожих предпочтений.
    """
    # Получить список предметов, оценненых обоим
    si={}
    for item in prefs[person1]:
        if item in prefs[person2]:
            si[item] = 1
    
    return len(si)

def topMatches(prefs,person,n=5,similarity=sim):
    """Возвращает список наилучших соответствий 
    для человека из словаря prefs. n
    и функция подобия - необязательные параметры.

    Args: 
        prefs: Список людей и их предпочтений.
        person: Человек, для которого составляем
            список ему подобных.
        n: Количество результатов в списке.
        similarity: Функция подобия.

    Returns:
        Возвращает список наилучших соответствий 
    для человека из словаря prefs.
    """
    scores=[(similarity(prefs,person,other),other) for other in prefs if other!=person]
        
    # Отсортировать список по убыванию оценок
    scores.sort()
    scores.reverse()
    return scores[0:n]
'''

Итак, нам надо узнать кто имеет схожии предпочтения с пользователем 'molly doe'. 

'''python

    from analysis import sim
    from analysis import topMatches
    import pickle

    f = open('log', 'r')
    gamers = pickle.load(f)
    print topMatches(gamers, 'molly doe', n=5, similarity=sim)
    f.close()
''' 

*Profit!*

##Заключение

Получить информацию просто. Провести хороший анализ более сложная задача. Задача этой статьи показать весь путь от начала и до успешного завершения. В дальнейшем я напишу более интересные способы анализа и что это может дать с точки зрения бизнеса. Вообще узнать информацию о будущих клиентах это круто. А помогать клиентам получать то что они хотят это вообще задача номер один. Именно по этому тысячи сайтов используют алгоритмы рекомендаций и улавливают предпочтения своих клиентов. 




